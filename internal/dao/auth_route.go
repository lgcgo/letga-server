// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package dao

import (
	"context"
	"letga/internal/consts"
	"letga/internal/dao/internal"
	"letga/internal/model"
	"letga/internal/model/do"

	"github.com/gogf/gf/v2/database/gdb"
)

// internalAuthRouteDao is internal type for wrapping internal DAO implements.
type internalAuthRouteDao = *internal.AuthRouteDao

// authRouteDao is the data access object for table auth_route.
// You can define custom methods on it to extend its functionality as you wish.
type authRouteDao struct {
	internalAuthRouteDao
}

var (
	// AuthRoute is globally public accessible object for table auth_route operations.
	AuthRoute = authRouteDao{
		internal.NewAuthRouteDao(),
	}
)

// Fill with you ideas below.

// 获取路由
func (d authRouteDao) Get(ctx context.Context, keyId uint) (*model.AuthRoute, error) {
	var (
		authRoute *model.AuthRoute
		err       error
	)
	// 扫描数据
	if err = d.Ctx(ctx).Where(do.AuthRoute{
		Id: keyId,
	}).Hook(HashSelectHook(ctx)).Scan(&authRoute); err != nil {
		return nil, err
	}
	return authRoute, nil
}

// 获取路由集
func (d authRouteDao) GetByIds(ctx context.Context, keyIds []uint) ([]*model.AuthRoute, error) {
	var (
		authRoute []*model.AuthRoute
		err       error
	)
	// 扫描数据
	if err = d.Ctx(ctx).WhereIn(d.Columns().Id, keyIds).Hook(HashSelectHook(ctx)).Scan(&authRoute); err != nil {
		return nil, err
	}
	return authRoute, nil
}

// 写入路由
func (d authRouteDao) Insert(ctx context.Context, data *do.AuthRoute) (*model.AuthRoute, error) {
	insertId, err := d.Ctx(ctx).Data(data).InsertAndGetId()
	if err != nil {
		return nil, err
	}
	return d.Get(ctx, uint(insertId))
}

// 更新路由
func (d authRouteDao) Update(ctx context.Context, data *do.AuthRoute) (*model.AuthRoute, error) {
	_, err := d.Ctx(ctx).Where(d.Columns().Id, data.Id).Data(data).Update()
	if err != nil {
		return nil, err
	}
	return d.Get(ctx, data.Id.(uint))
}

// 设置路由状态
func (d authRouteDao) SetStatus(ctx context.Context, keyId uint, value string) (*model.AuthRoute, error) {
	_, err := d.Ctx(ctx).Where(d.Columns().Id, keyId).Data(&do.AuthRoute{Status: value}).Update()
	if err != nil {
		return nil, err
	}
	return d.Get(ctx, keyId)
}

// 重置菜单ID
func (d authRouteDao) ResetMenuId(ctx context.Context, menuIds []uint) error {
	_, err := d.Ctx(ctx).WhereIn(d.Columns().MenuId, menuIds).Update(do.AuthRoute{
		MenuId: 0,
	})
	return err
}

// 删除域
func (d authRouteDao) Delete(ctx context.Context, keyIds []uint) error {
	_, err := d.Ctx(ctx).WhereIn(d.Columns().Id, keyIds).Delete()
	return err
}

// 分页数据
func (d authRouteDao) PageData(ctx context.Context, p *model.PageParams, s *model.AuthRouteSearch, handlers ...gdb.ModelHandler) ([]*model.AuthRoute, int, error) {
	var (
		count int
		data  []*model.AuthRoute
		err   error
	)
	handlers = append(handlers, SearchHandler(d.Table(), s, p.Search), PageHandler(p.PageSize, p.Current))
	err = d.Ctx(ctx).Handler(handlers...).Hook(HashSelectHook(ctx, d.Table())).WithAll().ScanAndCount(&data, &count, false)
	if err != nil {
		return nil, count, err
	}
	return data, count, nil
}

// 检测ID集
func (d authRouteDao) CheckIds(ctx context.Context, keyIds []uint) error {
	return CheckIds(ctx, d.Table(), keyIds, consts.TABLE_AUTH_ROUTE_SALT)
}

// 指定菜单ID集统计
func (d authRouteDao) CountByMenuIds(ctx context.Context, menuIDs []uint) (int, error) {
	return d.Ctx(ctx).WhereIn(d.Columns().MenuId, menuIDs).Count()
}

// 检测地址(含软删除)
func (d authRouteDao) IsPathMethodAvailable(ctx context.Context, path string, method string, notIds ...uint) (bool, error) {
	var (
		m     = d.Ctx(ctx)
		count int
		err   error
	)
	// 过滤统计
	for _, v := range notIds {
		m = m.WhereNot(d.Columns().Id, v)
	}
	if count, err = m.Where(do.AuthRoute{
		Path:   path,
		Method: method,
	}).Unscoped().Count(); err != nil {
		return false, err
	}
	return count == 0, nil
}
